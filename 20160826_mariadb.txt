2016-08-26
# edit by liu2lin600


MariaDB or MySQL：
   
    ♦ 版本迭代：
        MySQL：5.1 --> 5.5 --> 5.6 --> 5.7
        MariaDB：5.5.x --> 10.x

    ♦ 核心组件：
        连接池：认证、线程重用、连接数限制、内存检查、缓存
        SQL接口：DDL, DML, 关系型数据库的基本抽象
        分析器：查询转换、对象权限检查
        优化器：访问路径，性能相关的统计数据
        caches和buffers：与存储引擎自身相关的I/O性能提升工具
        存储引擎：
            MyISAM、InnoDB(变种XtraDB)、Memory、Merge、Federated、CSV、Archive、Blackholl、Aria、SphinxSE、TokuDB
        
    ♦ 基本特性：
        插件式存储引擎
        单进程多线程
            
    ♦ 安装方式：
        OS Vendor：系统发行版自带
        MySQL：
            1. source code：源码
                cmake工具
            2. binary package：二进制包
                i686, x86_64; 注间依赖glibc VERSION版本
            3. prepackage：预编译
                rpm, deb，注意os, arch区分 

    ♦ 配置文件：
        启动时会读取多处的多个配置文件，而且会以指定的次序的进行，不同的配置文件中出现同一参数且拥有不同值时，后读取将为最终生效值
            
        my_print_defaults命令：查看加载顺序
            默认顺序：/etc/mysql/my.cnf  /etc/my.cnf ~/.my.cnf 
                
        mysqld_safe命令：服务端启动
            --defaults-file=file_name   # 可修改默认读取的配置文件
            --defaults-extra-file=path  # 于读取的默认配置文件之外再加载一个文件     
                                    
        配置文件格式：
            ini风格的配置文件，能够为mysql的各种应用程序提供配置信息
            [mysqld]
            [mysqld_safe]
            [mysqld_multi]
            [server]
            [mysql]
            [mysqldump]
            [client]
            ...
            
                PARAMETER：不同版本参数方式有可能不同
                    innodb_file_per_table
                    innodb-file-per-table 
                  
    ♦ 安装后启动前建议：
        1. 安全初始化命令，包括清除匿名登录，添加root密码及远程登录
            mysql_secure_installation
                
        2. 运行前常修改的配置参数
            [mysqld]
            innodb_file_per_table=ON
            skip_name_resolve=ON
            ...
                
    ♦ 程序文件：
        服务端程序：mysqld_safe, mysqld_multi
        客户端程序：mysql, mysqldump, mysqladmin
        工具程序：myisampack, ...
        
        命令：
            客户端命令：于客户端执行
            服务端命令：SQL语句，需要一次性完整地发往服务端，语句必须有结束符      
             
        • mysql：客户端交互式CLI工具，mysql --> mysql protocol --> mysqld
                
            · 语法：mysql [options] db_name
                    mysql [options] [DATABASE] < /PATH/FROM/SOME_SQL_SCRIPT
                    
            · 常用选项：
                -h host_name：服务端地址，空格可省
                -u user_name：用户名，空格可省
                -p[password]：用户密码，安全起见不要在命令行直接输入密码
                -P port_num：服务端端口 
                --protocol={TCP|SOCKET|PIPE|MEMORY}：
                    本地通信：基于本地回环地址进行请求，将基于本地通信协议
                        Linux：SOCKET
                        Windows：PIPE，MEMORY
                    非本地通信：使用非本地回环地址进行的请求 TCP协议
                -S path：本机通讯socket文件路径
                --database=db_name, -D db_name：
                -C：数据压缩传输，双方都支持才行
                -e 语句：非交互模式执行SQL语句
                -E：查询结果纵向显示
                     
            · mysql命令帮助：
                man mysql
                mysql --help --verbose   

                MariaDB [(none)]> ：登录后可用客户端命令
                    ?         (\?) 帮助
                    clear     (\c) 中止语句执行，前不能有';'
                    connect   (\r) 重连
                    delimiter (\d) 修改结束符
                    exit|quit (\q) 退出
                    go        (\g) 发送语句
                    help      (\h) 显示帮助
                    source    (\.) 执行sql脚本
                    status    (\s) 获取服务器状态
                    system    (\!) 执行系统命令
                    use       (\u) 使用指定数据库
                    charset   (\C) 设定字符集

        • mysqld服务器程序：工作特性的定义方式
            1. 命令行选项
            2. 配置文件参数
                
            ◆ 变量/参数：
                · 显示：
                    mysql> SHOW [GLOBAL|SESSION] VARIABLES [LIKE ..];       # 服务器参数/变量，设定MySQL的运行特性
                    mysql> SHOW [GLOBAL|SESSION] STATUS [LIKE ..];          # 状态参数/变量，保存运行中的统计数据或状态
                    mysql> SELECT @@[global.|session.]system_var_name       # 显示单个变量设定值的方法

                · 通配符：
                    % ：任意长度任意字符
                    _ ：任意间个字符

                · 变量/参数级别：
                    1. 全局(GLOBAL)：为所有会话设定默认
                    2. 会话(SESSION)：跟单个会话相关，会话建立会从全局继承
                    
                · 服务器变量的调整方式：
                    1. 运行时修改，并非所有参数都能修改
                    2. 启动前通过配置文件修改
                    
                · 运行时修改操作方法：
                    mysql> SET [GLOBAL|SESSION] system_var_name = expr
                    mysql> SET [@@global.|@@session. | @@]system_var_name = expr

                示例：
                    mysql> SHOW GLOBAL STATUS LIKE '%select%';
                    mysql> SHOW GLOBAL VARIABLES LIKE '%commit%';
                    mysql> SELECT @@global.autocommit;
                    mysql> SET @@session.autocommit=OFF;
                    
    ♦ SQL标准：
        ANSI SQL 
            SQL-86, SQL-89, SQL-92, SQL-99, SQL-03, ...
            
    ♦ 数据类型：
        字符型、数值型、日期时间型、内建类型
        
        数据类型的功用：
            1、存储的值类型
            2、占据的最大存储空间
            3、定长、变长
            4、如何被索引和排序
            5、是否能够被索引

        数据字典：系统编目（system catalog）
            保存了数据库服务器上的元数据

            元数据：
                关系的名称
                每个关系中各字段的名称
                各字段的类型和长度
                约束
                每个关系上的视图的名字及视图的定义

                授权的用户名字
                用户的授权和帐户信息

                统计类数据
                    每个关系中字段数
                    每个关系中行数
                    每个关系的存储方法

            元数据也通过数据库保存：
                infomation_schema
                mysql
                performance_schema

        查看类型：mysql> HELP DATA TYPE
            
        • 字符型：
            CHAR(#)， BINARY：定长型；CHAR不区分字符大小写，而BINARY区分
            VARCHAR(#)， VARBINARY：变长型
            TEXT：TINYTEXT，TEXT，MEDIUMTEXT，LONGTEXT
            BLOB：TINYBLOB，BLOB，MEDIUMBLOB， LONGBLOB
        • 数值型：
            浮点型：近似
                FLOAT
                DOUBLE
                REAL
                BIT
            整型：精确
                INTEGER：TINYINT，SMALLINT，MEDIUMINT，INT，BIGINT
                DECIMAL
        • 日期时间型：
            日期：DATE
            时间：TIME
            日期时间：DATETIME
            时间戳：TIMESTAMP
            年份：YEAR(2), YEAR(4)
        • 内建：
            ENUM：枚举
                ENUM('Sun','Mon','Tue','Wed')
            SET：集合
                
        • 类型修饰符：
            字符型：NOT NULL，NULL，DEFALUT ‘STRING’，CHARACET SET ‘CHARSET’，COLLATION ‘collocation'
            整型：NOT NULL， NULL， DEFALUT value, AUTO_INCREMENT, UNSIGNED
            日期时间型：NOT NULL， NULL， DEFAULT 
        
    ♦ SQL MODE：
        定义mysqld对约束等违反时的响应行为等设定
        
        常用的MODE：
            TRADITIONAL: 常规
            STRICT_TRANS_TABLES: 非事务表严格限定
            STRICT_ALL_TABLES: 所有表严格限定
            
        修改方式：
            mysql> SET GLOBAL sql_mode='TRADITIONAL';
            mysql> SET @@global.sql_mode='STRICT_ALL_TABLES';
             
    ♦ SQL操作：
        DDL(数据定义语言)：定义关系、修改关系、删除关系、定义完整性约束、管理视图及访问权限
        DML(数据操纵语言)：插入行、修改行、删除行

        • DDL：
            查看：mysql> HELP Data Definition
            
                CREATE, ALTER, DROP
                    DATABASE, TABLE
                    INDEX, VIEW, USER
                    FUNCTION, FUNCTION UDF, PROCEDURE, TABLESPACE, TRIGGER, SERVER 
                    
            1. database：数据库
                CREATE DATABASE [IF NOT EXISTS] db_name CHARACTER SET [=] charset_name  COLLATE [=] collation_name
                ALTER DATABASE [db_name] CHARACTER SET [=] charset_name  COLLATE [=] collation_name
                DROP DATABASE [IF EXISTS] db_name
                SHOW DATABASES;     # 查看所有数据库
                USE DATABASE        # 选择指定数据库
                SELECT database();  # 查看所在数据库
                
            2. table：表
                · CREATE：创建
                    (1) CREATE [TEMPORARY] TABLE [IF NOT EXISTS] tbl_name
                        (create_definition,...)
                        [table_options]
                        [partition_options]
                        
                        table_options：表选项
                            ENGINE [=] engine_name
                            AUTO_INCREMENT [=] value
                            [DEFAULT] CHARCTER SET [=] name
                            ROW_FORMAT [=] {DEFAULT|DYNAMIC|FIXED|COMPRESSED|REDUNDANT|COMPACT}
                            ...
                            
                            查看支持的所有存储引擎：
                                mysql> SHOW ENGINES;
                            
                            查看指定表的存储引擎：
                                mysql> SHOW TABLE STATUS LIKE tb_name;
                            
                    (2) CREATE TABLE [IF NOT EXISTS] tbl_name
                        [(create_definition,...)]
                        [table_options]
                        [partition_options]
                        select_statement
                    
                        直接创建表，并将查询语句的结果插入到新创建的表中，如果创建字段与查询字段不一致时，都保留
            
                    (3) CREATE TABLE [IF NOT EXISTS] tbl_name LIKE old_tbl_name;
                        
                        复制某存在的表的结构来创建新的空表

                    示例：

                · DROP：删除
                    DROP [TEMPORARY] TABLE [IF EXISTS] tbl_name [, tbl_name]; 
                    
                · ALTER：修改
                    ALTER  TABLE tbl_name [alter_specification [, alter_specification] ...]
                        
                        可修改内容：
                            (1) table_options
                            (2) 添加定义: ADD 字段、字段集合、索引、约束
                            (3) 修改字段:
                                CHANGE [COLUMN] old_col_name new_col_name column_definition [FIRST|AFTER col_name]
                                MODIFY [COLUMN] col_name column_definition [FIRST | AFTER col_name]
                            (4) 删除操作: DROP 字段、索引、约束
                                
                    表重命名：
                        RENAME [TO|AS] new_tbl_name

                    注：修改存储引擎为新建表再复制后再删除原表，所以开销比较大，生产环境少用
                            
                · DESC：查看表结构
                    DESC table_name

                · 其它：
                    SHOW CREATE TABLE tbl_name;     # 查看表定义
                    SHOW TABLE STATUS [{FROM | IN} db_name] [LIKE 'pattern' | WHERE expr];  # 查看表属性信息
                    
            3. index：索引
                · 创建：
                    CREATE [UNIQUE|FULLTEXT|SPATIAL] INDEX index_name [index_type] ON tbl_name (index_col_name,...)
                    
                · 查看：
                    SHOW {INDEX | INDEXES | KEYS} {FROM | IN} tbl_name [{FROM | IN} db_name] [WHERE expr]
                    
                · 删除：
                    DROP  INDEX index_name ON tbl_name
                    
                · 索引类型：
                    聚集索引、非聚集索引：索引是否与数据存在一起
                    主键索引、辅助索引：
                    稠密索引、稀疏索引：是否索引了每一个数据项
                    BTREE（B+）、HASH、R Tree、FULLTEXT
                        BTREE：左前缀
                            
                · EXPLAIN：分析查询语句的执行路径
                
            4. view：视图，虚表，存储下来的SELECT语句
                · 创建：
                    CREATE  VIEW view_name [(column_list)] AS select_statement
                    
                · 修改：
                    ALTER  VIEW view_name [(column_list)] AS select_statement
                    
                · 删除：
                    DROP VIEW [IF EXISTS] view_name [, view_name] ...
                    
        • DML：
            查看：mysql> HELP Data Manipulation
                
                INSERT/REPLACE, DELETE, SELECT, UPDATE
                
            1. INSERT：添加，包括单行插入和批量插入
                
                (1) INSERT INTO tbl_name [(col_name,...)]
                    {VALUES | VALUE} ({expr | DEFAULT},...),(...),...
                    col_name=expr[, col_name=expr] ... ]

                (2) INSERT INTO tbl_name
                    SET col_name={expr | DEFAULT}, ...
                    col_name=expr[, col_name=expr] ... ]

                (3) INSERT INTO tbl_name [(col_name,...)]
                    SELECT ... col_name=expr[, col_name=expr] ... ]
                
            2. DELETE：删除
                
                DELETE  FROM tbl_name [WHERE where_condition] [ORDER BY ...] [LIMIT row_count]      
                
                    注意：一定要有限制条件，否则将清空整个表

                TRUNCATE tbl_name;  # 清空表并将自增值重置 
                         
            3. UPDATE：修改
                
                UPDATE table_reference SET col_name1={expr1|DEFAULT} [, col_name2={expr2|DEFAULT}] ...
                    [WHERE where_condition]
                    [ORDER BY ...]
                    [LIMIT row_count]               
                        
                注意：一定要有限制条件，否则将修改整个表中指定字段的数据
                    sql_safe_updates变量可阻止不带条件更新操作
                
            4. SELECT：查询
            
                Query Cache：缓存查询的执行结果
                    key：查询语句的hash值
                    value：查询语句的执行结果
            
                查询执行路径：
                    请求-->查询缓存
                    请求-->查询缓存-->解析器-->预处理器-->优化器-->查询执行引擎-->存储引擎-->缓存-->响应
                
                SELECT语句的执行流程：
                    FROM  --> WHERE --> Group By --> Having --> Order BY --> SELECT --> Limit 
                
                1. 单表查询：
                    SELECT [ DISTINCT | DISTINCTROW ]
                        [SQL_CACHE | SQL_NO_CACHE] [SQL_CALC_FOUND_ROWS]
                        select_expr [, select_expr ...]
                        [FROM table_references
                        [WHERE where_condition]
                        [GROUP BY {col_name | expr | position}
                        [ASC | DESC], ... [WITH ROLLUP]]
                        [HAVING where_condition]
                        [ORDER BY {col_name | expr | position}
                        [ASC | DESC], ...]
                        [LIMIT {[offset,] row_count | row_count OFFSET offset}] 
                        
                    用法：
                        SELECT col1, col2, ... FROM tble_name；
                        SELECT col1, col2, ... FROM tble_name WHERE clause；
                        SELECT col1, col2, ... FROM tble_name GROUP BY col_name HAVING clause； 
                        
                    DISTINCT：数据去重
                    SQL_CACHE：显式指定缓存查询语句的结果
                    SQL_NO_CACHE：显式指定不缓存查询语句的结果
                    
                    query_cache_type服务器变量有三个值：
                        ON：启用
                            SQL_NO_CACHE：不缓存，默认符合缓存条件都缓存
                        OFF：关闭
                        DEMAND：按需缓存
                            SQL_CACHE：缓存；默认不缓存
                            
                    字段可以使用别名 ：
                        col1 AS alias1, col2 AS alias2, ...
                        
                    • WHERE子句：指明过滤条件以实现"选择"功能
                        过滤条件：布尔型表达式
                        算术操作符：+, -, *, /, %
                        比较操作符：=, <>, !=, <=>, >, >=, <, <=
                        
                            IS NULL，IS NOT NULL
                            BETWEEN min AND max：区间
                            IN：列表
                            LIKE：模糊比较，%和_
                            RLIKE或REGEXP
                            
                        逻辑操作符：
                            AND， OR， NOT， XOR
                                
                    • GROUP BY：根据指定的字段把查询的结果进行分组，以用于聚合运算
                        avg(), max(), min(), sum(), count()
                        
                    • HAVING：对分组聚合后的结果进行条件过滤
                        
                    • ORDER BY：根据指定的字段把查询的结果进行排序
                        升序：ASC
                        降序：DESC 
                        
                    • LIMIT：对输出结果进行数量限制
                        LIMIT 3             # 前3条数据
                        LIMIT 2,3           # 越过2条取3条
                        LIMIT 3 OFFSET 2    # 同上
                        
                    
                2. 多表查询：
                    连接操作：
                        交叉连接：笛卡尔乘积，要避免
                        内连接：
                            等值连接: 让表之间的字段以等值的方式建立连接
                            不等值连接:
                            自然连接:
                            自连接:
                        外连接：
                            左外连接：
                                FROM tb1 LEFT JOIN tb2 ON tb1.col = tb2.col 
                            右外连接：
                                FROM tb1 RIGHT JOIN tb2 ON tb1.col = tb2.col 
                                
                3. 子查询：在查询中嵌套查询
                    
                    用于WHERE子句中的子查询：
                        (1) 用于比较表达式中的子查询：子查询仅能返回单个值 
                        (2) 用于IN中的子查询：子查询可以返回一个列表值
                        (3) 用于EXISTS中的子查询：

                    用于FROM子句中的子查询：
                        SELECT tb_alias.col1, ... FROM (SELECT clause) AS tb_alias WHERE clause; 
                        
                4. 联合查询：将多个查询语句的执行结果相合并
                    SELECT ... UNION SELECT ...;

    ♦ 存储引擎：
        ▫ 表类型：表级别概念，不建议在同一个库中的表上使用不同的ENGINE
        
        ▫ 查看表引擎：
            mysql> CREATE TABLE ... ENGINE[=]ENGINE_NAME;
            mysql> SHOW TABLE STATUS; 
        
        ▫ 常见的存储引擎：
            MyISAM, Aria(增加MyISAM), InnoDB, MRG_MYISAM, CSV, BLACKHOLE, MEMORY, PERFORMANCE_SCHEMA, ARCHIVE, FEDERATED
            
        • InnoDB：InnoBase公司
            Percona-XtraDB, Supports transactions, row-level locking, and foreign keys
                
            数据存储于"表空间(table space)"中：
                1. 所有InnoDB表的数据和索引存储于同一个表空间中
                    表空间文件：datadir定义的目录中，即ibdata1, ibdata2, ...

                2. innodb_file_per_table=ON         # 每表使用单独的表空间文件
                    数据文件(数据和索引，存储于数据库目录)：tbl_name.ibd 
                    表结构的定义：在数据库目录，tbl_name.frm 
                
            特点：
                适用场景：适合对事务要求较高的场景中，但较适用于处理大量短期事务
                数据存储：表空间
                并发：MVCC(Mutli Version Concurrency Control)，间隙锁(防止幻读)，行级锁
                索引：聚集索引、辅助索引
                性能：预读操作、内存数据缓冲、内存索引缓存、自适应Hash索引、插入操作缓存区
                备份：支持热备
                    
        • MyISAM：
            
            · 特点：
                支持全文索引（FULLTEXT index）、压缩、空间函数（GIS）
                不支持事务
                锁粒度，表级锁，加锁和并发
                崩溃无法保证表安全恢复
                延迟索引更新
                表压缩
                手动或自动修复、但可能会丢失数据
                非聚集索引
            
            · 适用场景：只读或读多写少的场景、较小的表（以保证崩溃后恢复的时间较短）
            
            · 文件：每个表有三个文件，存储于数据库目录中
                tbl_name.frm：表格式定义
                tbl_name.MYD：数据文件 
                tbl_name.MYI：索引文件
                
        • 行格式：
            DEFAULT|DYNAMIC|FIXED|COMPRESSED|REDUNDANT|COMPACT
             
        • 其它的存储引擎：
            1. CSV        ：将CSV文件（以逗号分隔字段的文本文件）作为MySQL表文件 
            2. MRG_MYISAM ：将多个MyISAM表合并成的虚拟表
            3. BLACKHOLE  ：类似于/dev/null，不真正存储数据
            4. MEMORY     ：内存存储引擎，支持hash索引，表级锁，常用于临时表
            5. FEDERATED  ：用于访问其它远程MySQL服务器上表的存储引擎接口
            
        • MariaDB额外支持第三方存储引擎：
            OLTP类：
                XtraDB: InnoDB的改进版
                PBXT: 支持ACID和MVCC
                TokuDB: 支持使用分形树的索引结构，适用存储大数据

            面向列的存储的引擎：按列为单位进行存储，适合压缩等，适用于存储大数据
                Infobright
                InfiniDB
                LucidDB

            社区引擎：
                Aria: 改进的MyISAM
                OQGraph: 支持图操作
                SphinxSE: 为sphinx全文搜索引擎提供了SQL接口
                Spider: 可以将数据切分成不同的分区，较透明实现分片功能

                搜索引擎：
                lucene, sphinx 
                    lucene：Solr, Elasticsearch
                    
    ♦ 并发控制：
        Lock 锁机制
        
        • 锁类型：
            读锁：共享锁，可被多个读操作共享，可能出现写饥饿，需定义好锁策略
            写锁：排它锁，独占锁
            
        • 锁粒度：
            表锁：在表级别施加锁，并发性较低
            行锁：在行级别施加锁，并发性较高
            
        • 锁策略：在锁粒度及数据安全性之间寻求一种平衡机制
            存储引擎级别：锁级别以及何时施加或释放锁由存储引擎自行决定
            MySQL Server：表级别，可自行决定，也允许显式请求 
                    
        • 锁类别：
            显式锁：用户手动请求的锁
            隐式锁：存储引擎自行根据需要施加的锁
            
        • 显式锁的使用：
            1. mysql> LOCK TABLES  tbl_name  read|write, tbl_name read|write, ...;     # 不同锁可定义不都锁类型
               mysql> UNLOCK TABLES;   # 释放所有锁
                
            2. mysql> FLUSH TABLES tbl_name,... [WITH READ LOCK];   # 将表内存数据写入磁盘并在内存中重新打开，可指定锁
               mysql> UNLOCK TABLES;
                
            3. mysql> SELECT ... [FOR UPDATE | LOCK IN SHARE MODE]  # 查询指定行并施加锁，并立即释放，用于事务中
                
    ♦ 事务机制：
        ✽ 注意：MyISAM不支持事务

        • 事务：一组原子性的SQL查询、或者是一个或多个SQL语句组成的独立工作单元
            事务日志：相关参数
                innodb_log_files_in_group   # 文件数据
                innodb_log_group_home_dir   # 日志路径
                innodb_log_file_size        # 每个文件大小
                innodb_mirrored_log_groups  # 文件组即保存几份，一般分别保存在不同磁盘上
        
        • ACID测试：
            A：Automicity(原子性)，整个事务中的所有操作要么全部成功执行，要么全部失败后回滚
            C：Consistency(一致性)，数据库总是应该从一个一致性状态转为另一个一致性状态
            I：Isolation(隔离性)，一个事务所做出的操作在提交之前，是否能为其它事务可见，保证并发操作
            D：Durability(持久性)，事务一旦提交，其所做出的修改会永久保存
            
        • 自动提交：
            mysql> SELECT @@autocommit;         # 默认为1，即单语句自动提交
            mysql> SET @@session.autocommit=0;  # 关闭单语句自动提交
            
        • 手动控制事务：
            启动：mysql> START TRANSACTION; 
            回滚：mysql> ROLLBACK;
            提交：mysql> COMMIT;
            
            事务支持savepoints：保存点
                mysql> SAVEPOINT identifier;            # 创建保存点
                mysql> ROLLBACK TO identifier;          # 回滚到指定保存点
                mysql> RELEASE SAVEPOINT identifier;    # 删除指定保存点
            
        • 事务隔离级别：
            1. READ-UNCOMMITTED : 读未提交 --> 脏读(可看到别人未提交的结果)
            2. READ-COMMITTED   : 读提交   --> 不可重复读(只能看到别人提交后的结果)
            3. REPEATABLE-READ  : 可重复读 --> 幻读(只有在自己提交后才能看到别人的提交)
            4. SERIALIZABLE     : 串行化

                注：级别越高并发性越低，默认为REPEATABLE-READ，一般可调整为READ-COMMITTED

            查看级别：tx_isolation参数
                mysql> SELECT @@session.tx_isolation;
                mysql> SET @@session.tx.isolation=READ-COMMITTED;

        • 查看InnoDB存储引擎的状态信息：
            mysql> SHOW ENGINE innodb STATUS;   # IO、缓存、缓冲、日志...
            
    ♦ 权限分类：
        类型：库级别、表级别、字段级别、管理类、程序类
        
        • 管理类：
            CREATE USER
            RELOAD
            LOCK TABLES
            REPLICATION CLIENT，REPLICATION SLAVE
            SHUTDOWN
            FILE
            SHOW DATABASES
            PROCESS 
            SUPER
            
        • 程序类：
            FUNCTION，PROCEDURE，TRIGGER
            
            操作：CREATE，ALTER，DROP，EXECUTE
            
        • 库和表级别：
            CREATE，ALTER，DROP
            INDEX
            CREATE VIEW
            SHOW VIEW
            GRANT
            OPTION: 能够把自己获得的权限生成一个副本转赠给其它用户
            
        • 数据操作：
            表：
                INSERT/DELETE/UPDATE/SELECT 
                
            字段：
                SELECT(col1,col2,...)
                UPDATE(col1,col2,...)
                INSERT(col1,col2,...)
                
        • 所有权限：ALL，ALL PRIVILEGES
        
        • 元数据数据库(数据字典)：mysql，默认生成的库
            表：db, host, user...
            字段：tables_priv, column_priv, procs_priv, proxies_priv...
                
    ♦ 用户管理：
        用户形式：
            'user'@'host';
                host: IP，主机名，NETWORK
                    
        • 创建用户：
            mysql> CREATE USER 'user'@'host' [IDENTIFIED BY 'PASS'] [,'user'@'host' [IDENTIFIED BY 'PASS']...];
            
        • 重命名：
            mysql> RENAME USER old_user TO new_user[, old_user TO new_user] ...;
            
        • 删除用户：
            mysql> DROP USER 'user'@'host' [, 'user'@'host'] ...;
            
        • 修改用户密码：
            1. mysql> SET PASSWORD [FOR 'user'@'host'] = PASSWORD('passwd_STR');
            2. mysql> UPDATE mysql.user SET Password=PASSWORD('passwd_STR')  WHERE User='USER' AND Host='HOST';
            3. mysqladmin -uUSER -hHOST -p  password 'NEW_PASS';   # 需要用户有SUPER权限才行
            
            ✽ 生效：mysql> FLUSH PRIVILEGES;
            
        • 忘记管理员密码的解决办法：
            (1) 启动mysqld进程时，使用--skip-grant-tables和--skip-networking选项
                mysqld_safe --skip-grant-tables --skip-networking
            (2) 通过UPDATE命令修改管理员密码
            (3) kill相关进程再以正常方式启动mysqld进程

            备：也可通过修改配置文件后(添加skip-grant-tables)再启动，完成后再将配置文件改回，在新版mysql中密码字段已修改为authentication_string，修改是需注意
            
        • 授权：GRANT
            mysql> GRANT priv_type [(column_list)] [, priv_type [(column_list)]] ...
                   ON [object_type] priv_level
                   TO 'user'@'host' [, 'user'@'host'] ...
                   [REQUIRE {NONE | ssl_option [[AND] ssl_option] ...}]
                   [WITH with_option ...]
                
                · priv_type：
                    ALL, SELECT, UPDATE, DELETE, INSERT, SUPER, 
                · [object_type]：
                    TABLE, FUNCTION, PROCEDURE
                · priv_level：
                    *, *.*, db_name.*, db_name.tbl_name, tbl_name, db_name.routine_name
                · [ssl_option]：
                    SSL      
                · [with_option]：
                    GRANT OPTION                     # 将自己权限赋予其它人
                    MAX_QUERIES_PER_HOUR count       # 每小时查询次数 
                    MAX_UPDATES_PER_HOUR count       # 每小时修改次数
                    MAX_CONNECTIONS_PER_HOUR count   # 每小时最大连接
                    MAX_USER_CONNECTIONS count       # 单用户并发数

                    备：修改此参数则重新设置为0
                    
        • 查看授权：SHOW GRANTS
            mysql> SHOW GRANTS [FOR 'user'@'host'];
                    
        • 取消授权：REVOKE
            mysql> REVOKE priv_type [(column_list)][, priv_type [(column_list)]] ...
                   ON [object_type] priv_level
                   FROM  'user'@'host' [,  'user'@'host'] ...;
                
            mysql> REVOKE ALL PRIVILEGES, GRANT OPTION FROM user [, user] ...;

            注：取消时确保授权级别一致
                
    ♦ 查询缓存：
        • 缓存：k/v方式存储 
            key：查询语句的hash值，(区分大小)所以查询语句风格尽量保持一致
            value：查询语句的执行结果
            
        • 如何判断缓存是否命中：
            通过查询语句的哈希值判断：哈希值考虑的因素包括
                查询本身、要查询数据库、客户端使用的协议版本、...
                
        • 哪些查询可能不会被缓存：
            1. 查询语句中包含UDF(用户自定义函数)
            2. 存储函数
            3. 用户自定义变量
            4. 临时表
            5. 系统表或者是包含列级别权限的查询
            6. 有着不确定结果值的函数(now()...)
            
        • 查询缓存相关的服务器变量：
            mysql> SHOW GLOBAL VARIABLES LIKE 'query%';

            · query_cache_limit：能够缓存的最大查询结果（单语句结果集大小上限）
                有着较大结果集的语句，显式使用SQL_NO_CACHE，以避免先缓存再移出 
            · query_cache_min_res_unit：内存块的最小分配单位，缓存过小的查询结果集会浪费内存空间
                较小的值会减少空间浪费，但会导致更频繁地内存分配及回收操作
                较大值的会带来空间浪费
            · query_cache_size：查询缓存空间的总共可用的大小，单位是字节，必须是1024的整数倍，运行时修改会清空缓存
            · query_cache_strip_comments：
            · query_cache_type：缓存功能启用与否
                ON：启用
                OFF：禁用
                DEMAND：按需缓存，仅缓存SELECT语句中带SQL_CACHE的查询结果
            · query_cache_wlock_invalidate：如果某表被其它连接锁定，是否仍然可以从查询缓存中返回查询结果，默认OFF为可以
        
        • 缓存状态变量：
            mysql> SHOW GLOBAL STATUS LIKE 'Qcache%';
            
            · Qcache_free_blocks      ：缓存空闲块
            · Qcache_free_memory      ：缓存空闲空间大小
            · Qcache_hits             ：命中次数
            · Qcache_inserts          ：向查询缓存中插入缓存的次数
            · Qcache_lowmem_prunes    ：超出可用内存而被清理的次数
            · Qcache_not_cached       ：未缓存次数
            · Qcache_queries_in_cache ：缓存中的条目数，小于等于Qcache_inserts 
            · Qcache_total_blocks     ：缓存总块数
            
            命中率：Qcache_hits/Com_select 

    ♦ 索引：
        • 索引的作用：加速查询操作，如是没索引，每次查询将进行全表扫描
            表中数据子集：把表中某个或某些字段(WHERE子句中用到的字段)的数据提取出来另存为一个特定数据结构组织的数据
                
        • 索引类型：B+ TREE，HASH
            ✧ B+ TREE：顺序存储，每一个叶子结点到根结点的距离相同，左前缀索引，适合于范围类型的数据查询
            
                ► 适用于B+ TREE索引的查询类型：
                    · 全值匹配：精确匹配某个值
                    · 匹配最左前缀：只精确起头的部分
                    · 匹配范围值：BETWEEN..AND..
                    · 精确匹配某一列，范围匹配另一列：对于组合多字段索引来说
                    · 只用访问索引的查询：覆盖索引(索引即要查询本身)
                
                ► 不适用B+ TREE索引：(组合字段索引)
                    · 如查条件不是从最左侧列开始，索引无效
                    · 不能跳过索引中的某列
                    · 如果查询中的某个列是为范围查询，那么其右侧的列都无法再使用索引优化查询

                √ 例子：在name,age字段上建立组合索引
                    where name like 'tom%'              # 用上索引
                    where name like '%tom'              # 用不上索引
                    where age = 18                      # 用不上索引
                    where name = 'tom%' and age < 22    # 用上索引
                
            ✧ Hash索引：基于哈希表实现，特别适用于值的精确
            
                ► 适用场景：只支持等值比较查询，例如=, IN(), <=>
                ► 不用场景：所有非精确值查询

            ✧ 聚集索引，非聚集索引：
                聚簇索引：索引和数据一起存放
                    数据文件：索引顺序文件
                非聚簇索引：索引和数据分开存放，而数据记录未必顺序存放，但索引数据一般顺序存放
                    数据文件：堆文件
                    
        • 索引优点：
            · 降低需要扫描的数据量，减少了IO次数
            · 可以帮助避免排序操作，避免使用临时表
            · 帮助将随机IO转为顺序IO
            
        • 高性能索引策略：
            1. 在WHERE中独立使用列，尽量其参与运算
            2. 左前缀索引：索引构建于字段的最左侧的多少个字符，要通过不重复的索引值和数据表的记录总数的比值来评估
            3. 多列索引：AND边接的多个查询条件更适合使用多列索引，而非多个单键索引
            4. 选择合适的索引列次序：选择性最高的放左侧
            
    ♦ EXPLAIN来分析索引有效性：
        mysql> EXPLAIN [EXTENDED|PARTITIONS] SELECT select_options
            
        输出结果分析：
                       id: 1
              select_type: SIMPLE
                    table: students
                     type: index_merge
            possible_keys: Name,Age
                      key: Name,Age
                  key_len: 152,1
                      ref: NULL
                     rows: 7
                    Extra: Using sort_union(Name,Age); Using where

            • id：当前查询语句中，每个SELECT语句的编号
                
                复杂的查询的类型主要三种：
                    1. 简单子查询
                    2. 用于FROM中的子查询
                    3. 联合查询
                    
                注意：联合查询的分析结果会出现一个额外的匿名临时表
                
            • select_type：查询类型：
                · SIMPLE      ：简单查询
                · SUBQUERY    ：简单子查询
                · DERIVED     ：用于FROM中的子查询
                · PRIMARY     ：联合查询中的第一个查询
                · UNION       ：联合查询中的第一个查询之后的其它查询
                · UNION RESULT：联合查询生成的临时表
                    
            • table：查询针对的表
            • type：关联类型，或称为访问类型，即MySQL如何去查询表中的行
                · ALL     ：全表扫描
                · index   ：根据索引的顺序进行的全表扫描，但同时如果Extra列出现了"Using index"表示使用了覆盖索引
                · range   ：有范围限制地根据索引实现范围扫描，扫描位置始于索引中的某一项，结束于另一项
                · ref     ：根据索引返回的表中匹配到某单个精确值的所有行（匹配给定值的行不止一个）
                · eq_ref  ：根据索引返回的表中匹配到某单个值的单一行，仅返回一个行，但需与某个额外的参考值比较，而不是常数
                · const   ：与某个常数比较，且只返回一行
                · system  ：同上

            • possiable_keys：查询中可能会用到的索引
            • key：查询中使用的索引
            • key_len：查询中用到的索引长度
            • ref：在利用key字段所显示的索引完成查询操作时所引用的列或常量值
            • rows：MySQL估计为找到所有的目标项而需要读取的行数
            • Extra：额外信息
                · Using index     ：使用了覆盖索引进行的查询
                · Using where     ：拿到数据后还要再次进行过滤
                · Using temporary ：使用了临时表以完成查询
                · Using filesort  ：对结果使用了一个外部索引排序
    
    ♦ 日志：
        • 查询日志   ：general_log
        • 慢查询日志 ：log_slow_queries
        • 错误日志   ：log_error, log_warnings
        • 二进制日志 ：binlog
        • 中继日志   ：relay_log
        • 事务日志   ：innodb_log_%

        注：二进制日志最好不要跟数据文件放同一磁盘上
        
        1、查询日志：记录查询语句，一般关闭
            · 存储位置：
                文件：file
                表：table (mysql.general_log)
            
            · 相关服务器变量：
                log_output={FILE|TABLE|NONE}    # 决定是否记录，记录时以何种方式记录
                general_log={ON|OFF}            # 是否启用
                general_log_file=HOSTNAME.log   # 记录为文件时的文件名
            
        2、慢查询日志：记录运行时间超出指定时长的查询
            · 存储位置：
                文件：FILE
                表：TABLE (mysql.slog_log)
            
            · 变量：
                long_query_time=10.00000        # session级别，默认为10s
                
                log_output={FILE|TABLE|NONE}    # 决定是否记录
                log_slow_queries={ON|OFF}       # 是否开启
                    slow_query_log={ON|OFF}     # 旧版本变量
                    slow_query_log_file=        # 旧版本变量
                log_slow_rate_limit             # 
                log_slow_verbosity              # 详细级别
                log_slow_filter=admin,filesort,filesort_on_disk,full_join,full_scan,query_cache,query_cache_miss,tmp_table,tmp_table_on_disk
                    定义过滤器

            注：有时并非语句本身执行比较慢，有可能出现阻塞等其它原因造成，mysql本身不会去分析具体原因
            
        3、错误日志：
            · 记录信息：
                (1) mysqld启动和关闭过程输出的信息
                (2) mysqld运行中产生的错误信息
                (3) event scheduler(定时运行器)运行时产生的信息
                (4) 主从复制架构中，从服务器复制线程启动时产生的日志
            
            · 变量：  
                log_error    = /var/log/mariadb/mariadb.log
                log_warnings = {ON|OFF}         # 是否把警告信息记录于错误日志中
            
        4、二进制日志：
            用于记录引起数据改变或存在引起数据改变的潜在可能性的语句(STATEMENT)或改变后的结果(ROW)，也可能是二者混合，用于replay(重放)作用，日志文件会自动滚动
            
            · 记录格式：
                binlog_format={STATEMENT|ROW|MIXED}
                    STATEMENT：sql语句
                    ROW：行，即语句执行结果，跟时下环境密切相关的语句时，如now()等
                    MIXED：混编，mysql自行决定
                
            · 查看二进制日志文件列表：
                mysql> SHOW MASTER|BINARY LOGS;
                +----------------+-----------+
                | Log_name       | File_size |
                +----------------+-----------+
                | log-bin.000001 |       245 |
                +----------------+-----------+

            · 手动滚动二进制日志：
                mysql> FLUSH LOGS;
                 
            · 查看当前正在使用的二进制日志文件：
                mysql> SHOW MASTER STATUS;
                +----------------+----------+--------------+------------------+
                | File           | Position | Binlog_Do_DB | Binlog_Ignore_DB |
                +----------------+----------+--------------+------------------+
                | log-bin.000001 |      330 |              |                  |
                +----------------+----------+--------------+------------------+

            · 查看二进制 日志文件中的事件：
                mysql> SHOW BINLOG EVENTS [IN 'log_name'] [FROM pos] [LIMIT [offset,] row_count]
                +----------------+-----+-------------+-----------+-------------+-------------------------------------------+
                | Log_name       | Pos | Event_type  | Server_id | End_log_pos | Info                                      |
                +----------------+-----+-------------+-----------+-------------+-------------------------------------------+
                | log-bin.000001 |   4 | Format_desc |         1 |         245 | Server ver: 5.5.50-MariaDB, Binlog ver: 4 |
                | log-bin.000001 | 245 | Query       |         1 |         330 | create database class                     |
                +----------------+-----+-------------+-----------+-------------+-------------------------------------------+
                
            · 服务器变量：
                log_bin=/PATH/TO/BIN_LOG_FILE   # 指定日志前缀，定义在配置文件中，重启生效
                sql_log_bin={ON|OFF}            # 是否开启记录功能
                max_binlog_size=1073741824      # 单文件最大
                sync_binlog={1|0}               # 是否直接将日志从内存同步到磁盘上
                
            · 客户端查看命令：
                mysqlbinlog [-hHOST] [-uUSER] [-p] [option] BIN_LOG_FILE

                常用选项：
                    --start-datetime='YYYY-MM-DD hh:mm:ss'
                    --stop-datetime='YYYY-MM-DD hh:mm:ss'
                    --start-position=NUM    # 从指定的事件位置查看
                    --stop-position=NUM     # 只显示到指定的事件位置
                
            · 二进制日志事件格式：
                # at 553
                #160831  9:56:08 server id 1  end_log_pos 624   Query   thread_id=2     exec_time=0     error_code=0
                SET TIMESTAMP=1472608568/*!*/;
                BEGIN
                /*!*/;
                
                事件的开始位置：# at 553
                事件发生的日期时间：#160831  9:56:08
                事件发生的服务器id：server id 1
                事件的结束位置：end_log_pos 624
                事件的类型：Query
                事件发生时所在服务器执行此事件的线程的ID： thread_id=2 
                语句的时间戳与将其写入二进制日志文件中的时间差：exec_time=0
                错误代码：error_code=0
                事件内容：SET TIMESTAMP=1472608568/*!*/;

                备：通常每个文件开始于245位置，开始部分用于记录版本等服务器信息
                
        5、中继日志：
            从服务器(slave)上记录下来从主服务器的二进制日志文件同步过来的事件
            
        6、事件日志：
            事务型存储引擎innodb用于保证事务特性的日志文件
                redo log 
                undo log 
                          
    ♦ 备份和恢复：数据级别
        备份：存储的数据副本，原始数据持续改变
        恢复：把副本应用到线上系统，仅能恢复至备份操作时刻的数据状态
        
        • 备份原因：
            1. 灾难恢复：硬件故障(冗余)、软件故障(bug)、自然灾害、黑客攻击、人为误操作...
            2. 测试：用于测试
            
        • 备份时应该注意事项：
            · 能容忍最多丢失多少数据
            · 恢复数据需要在多长时间内完成(类似消防系统)
            · 需要恢复哪些数据
            
             做恢复演练：
                测试备份的可用性
                增强恢复操作效率
                ...
            
        • 备份类型：从不同纬度划分如下
            ► 基于空间纬度(备份的数据的集范围)：
                完全备份：整个数据集(所有库所有表)
                部分备份：数据集的一部分，比如部分表
                    
            ► 基于时间纬度：
                完全备份：所有库所有表
                增量备份：仅备份自上一次完全备份或增量备份以来发生变化的那部数据
                差异备份：仅备份自上一次完全备份以来发生变化的那部数据
                
            ► 物理或逻辑层面：
                物理备份：复制数据文件进行备份
                逻辑备份：从数据库导出数据另存在一个或多个文件中
                
            ► 根据数据服务是否在线：
                热备份：读写操作均可进行的状态下所做的备份
                温备份：可读但不可写状态下进行的备份
                冷备份：读写操作均不可进行的状态下所做的备份
        
        • 备份需要考虑因素：
            · 锁定资源多长时间？
            · 备份过程的时长？
            · 备份时的服务器负载？
            · 恢复过程的时长？
        
        • 备份策略：
            完全+差异 (热温冷)
            完全+增量 (热温冷) 
            
            备份手段：物理、逻辑
            
        • 备份内容：
            · 数据
            · 二进制日志、InnoDB的事务日志
            · 代码(存储过程、存储函数、触发器、事件调度器)
            · 服务器的配置文件
            
        • 备份工具：
            ► mysqldump：mysql服务自带的备份工具，逻辑备份工具，支持完全、部分备份
                InnoDB：热备
                MyISAM：温备

            ► cp/tar：复制打包方式远程复制数据文件
                lvm2：创建快照(请求一个全局锁)，之后立即释放锁，达到几乎热备的效果物理备份
                注意：不能仅备份数据文件，要同时备份事务日志
                    前提：要求数据文件和事务日志位于同一个逻辑卷

            ► xtrabackup：由Percona提供，开源工具，支持对InnoDB做热备，物理备份工具
                完全备份、部分备份
                完全备份、增量备份

                对InnoDB：热备，支持完全备份和增量备份
                对MyISAM引擎：温备，只支持完全备份

            ► select：
                备份：SELECT ... INTO OUTFILE 'FILENAME';
                恢复：CREATE TABLE ...
                导入：LOAD DATA ...
                
        1. mysqldump方式备份：逻辑备份、完全备份、部分备份
            · 二次封装工具：
                mydumper、phpMyAdmin...
                
            · 格式： 
                mysqldump [OPTIONS] database [tables]                   # 不包含创建数据库语句
                mysqldump [OPTIONS] --databases [OPTIONS] DB1 [DB2...]  # 包含创建数据库语句
                mysqldump [OPTIONS] --all-databases [OPTIONS]           # 
                
            · 选项：
                MyISAM存储引擎：支持温备，备份时要锁定表
                    -x, --lock-all-tables：锁定所有库的所有表，读锁
                    -l, --lock-tables    ：锁定指定库所有表
                    
                InnoDB存储引擎：支持温备和热备
                    --single-transaction：创建一个事务，基于此快照执行备份
                    
                其它选项：
                    -R, --routines：存储过程和存储函数
                    --triggers    ：触发器
                    -E, --events  ：事件
                    --flush-logs：锁定表完成后，即进行日志刷新操作
                    --master-data[=1|2]：
                        1：记录为CHANGE MASTER TO语句，此语句不被注释
                        2：记录为CHANGE MASTER TO语句，此语句被注释
                    
            · 恢复：
                mysql [-uUSER] [-hHOST] [-p] [Database] < /path/to/FILE.sql
     
        2. 基于lvm2的备份：完全备份+binlog
        
            · 前提：数据目录位于逻辑卷，包含了数据文件和事务日志
                pvcreate /dev/sda6
                vgcreate myvg /dev/sda6
                lvcreate -L +5G -n mydata myvg
                mke2fs -t ext4 -b 2048 /dev/myvg/mydata
                blkid /dev/myvg/mydata --> /etc/fstab       # 添加开机自动挂载
                mount /dev/myvg/mydata /mydata
                mkdir -pv /mydata/{data,logs}
                chown -R mysql:mysql /mydata

                vim /etc/my.cnf 修改添加
                    [mysqld]
                    datadir=/mydata/data
                    innodb_file_per_table = ON
                    skip_name_resolve = ON
                    log_bin = /mydata/logs/log_bin

                启动mariadb
            
            · 备份：
                (1) 请求锁定所有表
                    mysql> FLUSH TABLES WITH READ LOCK;
                    
                (2) 记录二进制文件事件位置
                    mysql> FLUSH LOGS;
                    mysql> SHOW MASTER STATUS;
                    
                    mysql  -e  'SHOW MASTER STATUS;' >> /PATH/TO/SOME_POS_FILE
                    
                (3) 创建快照卷，注意数据大小设置相应值
                    lvcreate  -L +1G -s -p r -n my_snapshoot /dev/myvg/mydata 
                    
                (4) 释放锁
                    mysql> UNLOCK TABLES;
                    
                (5) 挂载快照卷，并执行备份
                    mount /dev/myvg/my_snapshoot /mnt       # 挂载快照
                    cp -a /mnt/data /root/backup-160901     # 从快照中复制数据

                (6) 周期性备份二进制日志(增量) 
                    cp /mydata/logs/log_bin.xxx /root/backup-160901

            · 恢复：
                (1) 将备份的数据放置对应数据目录，注意权限，然后启动服务
                (2) 将二进制日志重放
                    mysqlbinlog /root/backup-160901/log_bin.xxx > /tmp/160901
                    mysql> set @@session.sql_log_bin=OFF
                    mysql> \. /tmp/160901
                    mysql> set @@session.sql_log_bin=ON
                    mysql> FLUSH LOGS;
                    mysql -e 'SHOW MASTER STATUS' >> /PATH/TO/SOME_POS_FILE

        3. Xtrabackup：
            MyISAM：温备，不支持增量备份
            InnoDB：热备，增量
            
            实验环境：
                percona-xtrabackup-2.2.9-4.el7.x86_64

            (1) 完全备份+binlog：
                最小权限：
                    mysql> GRANT RELOAD, LOCK TABLES, REPLICATION CLIENT ON *.* TO 'bkuser'@'172.16.%.%' IDENTIFIED BY 'bkpass';
                    mysql> FLUSH PRIVILEGES;
                备份：innobackupex --user=bkuser --password=bkpass [--host=]  /tmp/backup       # 尽量使用绝对路径
                准备：innobackupex --apply-log /tmp/backup/2016-09-01_17-17-02                  # 注意数据路径权限
                恢复：innobackupex --copy-back /tmp/backup/2016-09-01_17-17-02
                      chown -R mysql:mysql /var/lib/mysql                                       # 修改恢复后的数据权限

                    注意：--copy-back需要在mysqld主机本地进行，mysqld服务不能启动，根据配置文件自动读取数据目录将数据复制过去
                        注意查看生成的数据文件中ib_logfile0文件大小，如果不是50M可能会启动失败
                        需设定/etc/my.cnf文件中的innodb_log_file_size值修改为ib_logfile0文件大小

                    二进制文件还原：
                        mysqlbinlog lob-bin.xxx --start-postition=NUM > /tmp/xxx    # 位置开始处从xtrabackup_binlog_info查看
                        mysql> set @@session.sql_log_bin=OFF;
                        mysql> \. /tmp/xxx;
                        mysql> set @@session.sql_log_bin=ON;
                        mysql> FLUSH LOGS;
                        mysql -e 'SHOW MASTER STATUS' >> /PATH/TO/SOME_POS_FILE


                备份生成文件：
                    backup-my.cnf           # 部分innodb配置
                    xtrabackup_binlog_info  # binlog文件及备份时的位置
                    xtrabackup_checkpoints  # 类型(完全或部分)，日志序列号开始到结束
                    xtrabackup_info         # 详细信息
                    xtrabackup_logfile      # 二进制日志，如果不小心cat的话会比较乱码，使用reset命令

                ✽ 注：备份恢复后最好做一次完全备份
                        
            (2) 完全+增量+binlog： 
                备份：完全+增量+增量+...+binlog
                      完全+差异+binlog

                增量备份：完全备份同上，目录为BASEDIR，尽量使用绝对路径
                    innobackupex --incremental /backup --incremental-basedir=BASEDIR            # 第一次增量基于完全备份
                    innobackupex --incremental /backup --incremental-basedir=LAST_INCRE_DIR     # 基于上次增量的增量备份
                    ...
                    
                    或: innobackupex --incremental /backup --incremental --incremental-basedir=BASEDIR
                        基于上一次增量备份的增量，如再基于完全则为差异备份，还原时只要应用最后一次差异即可
                
                准备：以下路径尽量使用绝对路径
                    innobackupex --apply-log --redo-only BASEDIR 
                    innobackupex --apply-log --redo-only BASEDIR --incremental-dir=INCREMENTAL-DIR1
                    innobackupex --apply-log --redo-only BASEDIR --incremental-dir=INCREMENTAL-DIR2
                    ...

                    注：--redo-only: 不对未完成的事务做回滚，有可能在下一次增量备份时会完成当前未完成的事务，但在最后一次增量应回滚
                    
                恢复：
                    1. innobackupex --copy-back BASEDIR
                       chown -R mysql.mysql BASEDIR
                    2. 二进制日志还原同上
                    
            备份单库选项：
                --databases=LIST

        4. select方式：备份表
            如：数据库为db，表为stu

            mysql> SELECT * FROM db.stu INTO  OUTFILE 'backup.txt';     # 相对路径，直接在数据目录中生成
            mysql> CREATE TABLE LIKE db.stu;                            # 创建空表
            mysql> LOAD DATA INFILE 'backup.txt' INTO TABLE db.stu;     # 导入表数据

        √ 备份方式总结：
            1. mysqldump+binlog
            2. lvm2+cp/tar+binlog
            3. xtrabackup(innodb)+binlog 
            
    ♦ MySQL复制：
        ▪ 主从复制：
            • Master/Slave架构：
                Master：write/read
                    binlog dump:：将从服务的io thread发出读取二进制日志事件的请求对应的数据发送给对方
                Slaves：read
                    IO thread：向master请求二进制日志中的事件
                    SQL thread：从中继日志中读取事件并在本地执行
                
            • 为什么？：
                冗余：promte（提升为主），异地灾备
                负载均衡：转移一部分read请求
                支援安全的备份操作：将从服务器离线用于冷备份
                ...
                
            • 主/从架构模型：
                异步复制、半同步复制、一主多从、一从一主
                    一从多主: (MariaDB 10)每个主服务器提供不同的数据库

            • 数据库扩展的思路：
                复制、切片

            • 复制有三个步骤：
                1. 在主库上启用二进制日志
                2. 备库从主库复制二进制日志，并保存至本地的中继日志中
                3. 备库从中继日志中读取事件并于本地执行一次

                        
            • 配置：
                前提：
                    · 时间：同步
                    · 程序版本：从服务器mysqld程序版本必须等于或高于主服务器
                    · 复制的开始位置：
                        1. 从0开始，适用主从均为新建立的服务器
                        2. 从主服务器备份中恢复到从节点后启动的复制
                    
                ► 主服务器：master
                    配置文件：my.cnf
                        server_id=#         # 定义服务id
                        log_bin=log-bin     # 开启二进制日志
                    
                    启动服务：授权
                        mysql> GRANT REPLICATION SLAVE,REPLICATION CLIENT ON *.* TO 'USER'@'HOST' IDENTIFIED BY 'YOUR_PASSWORD';
                        mysql> FLUSH PRIVILEGES;
                    
                ► 从服务器：slave
                    配置文件：my.cnf
                        server_id=#             # 服务id
                        relay_log=relay-log     # 开启中继日志
                        read_only=ON            # 只读
                    
                    启动服务：
                        mysql> CHANGE MASTER TO MASTER_HOST='HOST',MASTER_USER='USER',MASTER_PASSWORD='YOUR_PASSWORD',MASTER_LOG_FILE='BINLOG_NAME',MASTER_LOG_POS=#;
                        
                        mysql> START SLAVE [IO_THREAD|SQL_THREAD];      # 启动IO及SQL线程
                        mysql> SHOW SLAVE STATUS\G;                       # 查看从服务器状态

                    停止服务：
                        mysql> STOP SLAVE;

                        CHANGE MASTER TO选项：
                            MASTER_BIND = 'interface_name'
                            MASTER_HOST = 'host_name'               # 指明要连接的主节点，值类型字串
                            MASTER_USER = 'user_name'               # 具有复制权限的账号，值类型为字串 
                            MASTER_PASSWORD = 'password'            # 上述用户的密码，值类型为字串 
                            MASTER_PORT = port_num
                            MASTER_CONNECT_RETRY = interval
                            MASTER_HEARTBEAT_PERIOD = interval
                            MASTER_LOG_FILE = 'master_log_name'     # 复制起点，主节点上二进制日志，值类型为字串
                            MASTER_LOG_POS = master_log_pos         # 复制起点，主节点上二进制日志中起始事件的位置，值类型为数值
                            RELAY_LOG_FILE = 'relay_log_name'
                            RELAY_LOG_POS = relay_log_pos
                            MASTER_SSL = {0|1}                      # 是否启用ssl
                            MASTER_SSL_CA = 'ca_file_name'          # ca证书文件
                            MASTER_SSL_CAPATH = 'ca_directory_name'
                            MASTER_SSL_CERT = 'cert_file_name'
                            MASTER_SSL_KEY = 'key_file_name'
                            MASTER_SSL_CIPHER = 'cipher_list'
                            MASTER_SSL_VERIFY_SERVER_CERT = {0|1}
                            IGNORE_SERVER_IDS = (server_id_list)    # 忽略哪些服务器
                
        ▪ 主主复制：
            • 互为主从：两个节点各自都要开启binlog和relay log
                1. 数据不一致
                2. 自动增长id
                    定义一个节点使用奇数id
                        auto_increment_offset=1         # 起始
                        auto_increment_increment=2      # 步径
                    另一个节点使用偶数id
                        auto_increment_offset=2
                        auto_increment_increment=2

                    注：此法会出现id不连续情况，最好解决方案为配置一个id生成服务器专门用于生成并分配id

            • 配置：
                A节点：
                    [mysqld]
                    server-id=1
                    log_bin=bin-log
                    relay_log=relay-log
                    auto_increment_increment = 2
                    auto_increment_offset = 1

                B节点：
                    [mysqld]
                    server_id=21
                    log_bin=bin-log
                    relay_log=relay-log
                    auto_increment_increment = 2
                    auto_increment_offset = 2
                
                服务启动后执行如下两步：
                    1. 都授权有复制权限的用户账号
                        mysql> GRANT REPLICATION SLAVE,REPLICATION CLIENT ON *.* TO ...
                    2. 各把对方指定为主节点
                        mysql> CHANDE MASTER TO ...

                    注：具体参考主从复制配置

        ▪ 半同步复制：
            master要等待一个从节点把数据完整复制过去，由google贡献的补丁，以插件的方式存在

            • 支持多种插件：/usr/lib64/mysql/plugins/目录 (rpm方式时)
        
            • 需要安装方可使用：
                mysql> INSTALL PLUGIN plugin_name SONAME 'shared_library_name'; 
                
            • 半同步复制共享库：
                semisync_master.so
                semisync_slave.so
            
            • 配置：
                1. 主节点：
                    mysql> INSTALL PLUGIN rpl_semi_sync_master SONAME 'semisync_master.so';
                    mysql> SHOW GLOBAL VARIABLES LIKE 'rpl_semi%';
                        +------------------------------------+-------+
                        | Variable_name                      | Value |
                        +------------------------------------+-------+
                        | rpl_semi_sync_master_enabled       | OFF   |      # 已装载但未启用
                        | rpl_semi_sync_master_timeout       | 10000 |      # 等待从服务写入完全超时时长，超时后降为异步
                        | rpl_semi_sync_master_trace_level   | 32    |
                        | rpl_semi_sync_master_wait_no_slave | ON    |
                        +------------------------------------+-------+          

                    mysql> SET GLOBAL rpl_semi_sync_master_enabled=ON;  # 启用半同步
                        
                2. 从节点：
                    mysql> INSTALL PLUGIN rpl_semi_sync_slave SONAME 'semisync_slave.so';
                    mysql> SHOW GLOBAL VARIABLES LIKE 'rpl_semi%';                        
                        +---------------------------------+-------+
                        | Variable_name                   | Value |
                        +---------------------------------+-------+
                        | rpl_semi_sync_slave_enabled     | OFF   |
                        | rpl_semi_sync_slave_trace_level | 32    |
                        +---------------------------------+-------+         
                    
                    mysql> STOP SLAVE IO_THREAD;
                    mysql> SET GLOBAL rpl_semi_sync_slave_enabled=ON;   # 启用半同步
                    mysql> START SLAVE IO_THREAD;
                    
            • 判断方法：
                主节点：查看从节点信息
                    mysql> SELECT GLOBAL STATUS LIKIE 'rpl_semi%';
                    或：mysql> SELECT @@global.rpl_semi_sync_master_clients;

        ▪ 复制时应该注意的问题：
            1、从服务设定为"只读"，在从服务器启动read_only，但仅对非SUPER权限的用户有效
                
                mysql> SET GLOBAL read_only = 1;     # 命令行设置
 
                [mysqld]                             # 配置文件中修改
                read_only = 1
                
                mysql> FLUSH TABLES WITH READ LOCK;  # 阻止所有用户
                    
            2、尽量确保复制时的事务安全
                在master节点启用参数：
                    sync_binlog = ON    # 将事务提交立刻同步到磁盘
                    
                如果用到的是InnoDB存储引擎：
                    innodb_flush_logs_at_trx_commit=ON      # 有事务提交时就将事务日志的刷写到磁盘
                    innodb_support_xa=ON                    # 支持分布式提交
                        
            3、从服务器意外中止时尽量避免自动启动复制线程
            4、从节点上记录主节点同步信息，master.info
                sync_master_info=ON
                sync_relay_log_info=ON

            5、跟复制功能相关的文件
                master.info：保存slave连接master时所需要信息；纯文本文件
                relay-log.info：保存了当前slave节点上（主节点上的）二进制日志和当前节点中继日志的对应关系
    
        ▪ 复制过滤器：
            仅复制有限一个或几个数据库相关的数据，而非所有，由复制过滤器进行
        
            2种实现思路：
                (1) 主服务器仅向二进制日志中记录有关特定数据库相关的写操作
                    问题：其它库的point-recovery将无从基于binlog实现，不常用
                    
                    配置参数：
                        binlog_do_db=       # 数据库白名单，多个间逗号隔开
                        binlog_ignore_db=   # 数据库黑名单
                
                (2) 从服务器的SQL THREAD仅重放关注数据库或表相关的事件，并将其应用于本地
                    问题：增加网络IO和磁盘IO
                    
                    配置参数：
                        Replicate_Do_DB=                # 库白名单
                        Replicate_Ignore_DB=
                        Replicate_Do_Table=             # 表白名单
                        Replicate_Ignore_Table=
                        Replicate_Wild_Do_Table=        # 基于通配置符的表白名单
                        Replicate_Wild_Ignore_Table=

        ▪ 复制监控和维护：
            1. 清理日志：PURGE 
                PURGE { BINARY | MASTER } LOGS { TO 'log_name' | BEFORE datetime_expr };
                    清楚指定的文件或时间之前的日志，指定的文件或日期不会被清理

            2. 复制监控：
                    mysql> SHOW MASTER STATUS;
                    mysql> SHOW BINLOG EVENTS;
                    mysql> SHOW BINARY LOGS;
                    
                    mysql> SHOW SLAVE STATUS;
                
                        Seconds_Behind_Master: 0    # 判断从服务器是否落后于主服务器，为0则为同步
                        
            3. 如何确定主从节点数据是否一致：
                通过表的CHECKSUM检查
                使用percona-tools中pt-table-checksum
                
            4. 主从数据不一致时的修复方法：
                重新复制




补充：

    MySQL Show命令总结

        show tables或show tables from database_name;          显示当前数据库中所有表的名称。
        show tables like ‘my_%’;         显示当前数据库中以my_开头的表。
        show databases;          显示mysql中所有数据库的名称。
        show [full] columns from table_name from database_name; 或show [full] columns from database_name.table_name;          显示表中列名称。
        show grants for user_name;           显示一个用户的权限，显示结果类似于grant 命令。
        show index from table_name;          显示表的索引。
        show status;(show master status;show slave status)           显示一些系统特定资源的信息，例如，正在运行的线程数量。
        show variables;          显示系统变量的名称和值。
        show [full] processlist;         显示系统中正在运行的所有进程，也就是当前正在执行的查询。大多数用户可以查看他们自己的进程，但是如果他们拥有process权限，就可以查看所有人的进程，包括密码。
        show table status;           显示当前使用或者指定的database中的每个表的信息。信息包括表类型和表的最新更新时间。
        show privileges;         显示服务器所支持的不同权限。
        show create database database_name;          显示create database 语句是否能够创建指定的数据库。
        show create table table_name;        显示create database 语句是否能够创建指定的数据库。
        show engies;         显示安装以后可用的存储引擎和默认引擎。
        show innodb status;          显示innoDB存储引擎的状态。
        show logs;           显示BDB存储引擎的日志。
        show warnings;           显示最后一个执行的语句所产生的错误、警告和通知。
        show errors;         只显示最后一个执行语句所产生的错误。
        show [storage] engines; –显示安装后的可用存储引擎和默认引擎。
    
    日志相关的服务器参数详解：
        expire_logs_days={0..99}
        设定二进制日志的过期天数，超出此天数的二进制日志文件将被自动删除。默认为0，表示不启用过期自动删除功能。如果启用此功能，自动删除工作通常发生在MySQL启动时或FLUSH日志时。作用范围为全局，可用于配置文件，属动态变量。

        general_log={ON|OFF}
        设定是否启用查询日志，默认值为取决于在启动mysqld时是否使用了--general_log选项。如若启用此项，其输出位置则由--log_output选项进行定义，如果log_output的值设定为NONE，即使用启用查询日志，其也不会记录任何日志信息。作用范围为全局，可用于配置文件，属动态变量。
         
        general_log_file=FILE_NAME
        查询日志的日志文件名称，默认为“hostname.log"。作用范围为全局，可用于配置文件，属动态变量。

        binlog-format={ROW|STATEMENT|MIXED}
        指定二进制日志的类型，默认为STATEMENT。如果设定了二进制日志的格式，却没有启用二进制日志，则MySQL启动时会产生警告日志信息并记录于错误日志中。作用范围为全局或会话，可用于配置文件，且属于动态变量。

        log={YES|NO}
        是否启用记录所有语句的日志信息于一般查询日志(general query log)中，默认通常为OFF。MySQL 5.6已经弃用此选项。
         
        log-bin={YES|NO}
        是否启用二进制日志，如果为mysqld设定了--log-bin选项，则其值为ON，否则则为OFF。其仅用于显示是否启用了二进制日志，并不反应log-bin的设定值。作用范围为全局级别，属非动态变量。
         
        log_bin_trust_function_creators={TRUE|FALSE}
        此参数仅在启用二进制日志时有效，用于控制创建存储函数时如果会导致不安全的事件记录二进制日志条件下是否禁止创建存储函数。默认值为0，表示除非用户除了CREATE ROUTING或ALTER ROUTINE权限外还有SUPER权限，否则将禁止创建或修改存储函数，同时，还要求在创建函数时必需为之使用DETERMINISTIC属性，再不然就是附带READS SQL DATA或NO SQL属性。设置其值为1时则不启用这些限制。作用范围为全局级别，可用于配置文件，属动态变量。
         
        log_error=/PATH/TO/ERROR_LOG_FILENAME
        定义错误日志文件。作用范围为全局或会话级别，可用于配置文件，属非动态变量。
         
        log_output={TABLE|FILE|NONE}
        定义一般查询日志和慢查询日志的保存方式，可以是TABLE、FILE、NONE，也可以是TABLE及FILE的组合(用逗号隔开)，默认为TABLE。如果组合中出现了NONE，那么其它设定都将失效，同时，无论是否启用日志功能，也不会记录任何相关的日志信息。作用范围为全局级别，可用于配置文件，属动态变量。
         
        log_query_not_using_indexes={ON|OFF}
        设定是否将没有使用索引的查询操作记录到慢查询日志。作用范围为全局级别，可用于配置文件，属动态变量。
         
        log_slave_updates
        用于设定复制场景中的从服务器是否将从主服务器收到的更新操作记录进本机的二进制日志中。本参数设定的生效需要在从服务器上启用二进制日志功能。
         
        log_slow_queries={YES|NO}
        是否记录慢查询日志。慢查询是指查询的执行时间超出long_query_time参数所设定时长的事件。MySQL 5.6将此参数修改为了slow_query_log。作用范围为全局级别，可用于配置文件，属动态变量。
         
        log_warnings=#
        设定是否将警告信息记录进错误日志。默认设定为1，表示启用；可以将其设置为0以禁用；而其值为大于1的数值时表示将新发起连接时产生的“失败的连接”和“拒绝访问”类的错误信息也记录进错误日志。

        long_query_time=#
        设定区别慢查询与一般查询的语句执行时间长度。这里的语句执行时长为实际的执行时间，而非在CPU上的执行时长，因此，负载较重的服务器上更容易产生慢查询。其最小值为0，默认值为10，单位是秒钟。它也支持毫秒级的解析度。作用范围为全局或会话级别，可用于配置文件，属动态变量。

        max_binlog_cache_size{4096 .. 18446744073709547520}
        二进定日志缓存空间大小，5.5.9及以后的版本仅应用于事务缓存，其上限由max_binlog_stmt_cache_size决定。作用范围为全局级别，可用于配置文件，属动态变量。

        max_binlog_size={4096 .. 1073741824}
        设定二进制日志文件上限，单位为字节，最小值为4K，最大值为1G，默认为1G。某事务所产生的日志信息只能写入一个二进制日志文件，因此，实际上的二进制日志文件可能大于这个指定的上限。作用范围为全局级别，可用于配置文件，属动态变量。

        max_relay_log_size={4096..1073741824}
        设定从服务器上中继日志的体积上限，到达此限度时其会自动进行中继日志滚动。此参数值为0时，mysqld将使用max_binlog_size参数同时为二进制日志和中继日志设定日志文件体积上限。作用范围为全局级别，可用于配置文件，属动态变量。

        innodb_log_buffer_size={262144 .. 4294967295}
        设定InnoDB用于辅助完成日志文件写操作的日志缓冲区大小，单位是字节，默认为8MB。较大的事务可以借助于更大的日志缓冲区来避免在事务完成之前将日志缓冲区的数据写入日志文件，以减少I/O操作进而提升系统性能。因此，在有着较大事务的应用场景中，建议为此变量设定一个更大的值。作用范围为全局级别，可用于选项文件，属非动态变量。
         
        innodb_log_file_size={108576 .. 4294967295}
        设定日志组中每个日志文件的大小，单位是字节，默认值是5MB。较为明智的取值范围是从1MB到缓存池体积的1/n，其中n表示日志组中日志文件的个数。日志文件越大，在缓存池中需要执行的检查点刷写操作就越少，这意味着所需的I/O操作也就越少，然而这也会导致较慢的故障恢复速度。作用范围为全局级别，可用于选项文件，属非动态变量。
         
        innodb_log_files_in_group={2 .. 100}
        设定日志组中日志文件的个数。InnoDB以循环的方式使用这些日志文件。默认值为2。作用范围为全局级别，可用于选项文件，属非动态变量。
         
        innodb_log_group_home_dir=/PATH/TO/DIR
        设定InnoDB重做日志文件的存储目录。在缺省使用InnoDB日志相关的所有变量时，其默认会在数据目录中创建两个大小为5MB的名为ib_logfile0和ib_logfile1的日志文件。作用范围为全局级别，可用于选项文件，属非动态变量。


        relay_log=file_name
        设定中继日志的文件名称，默认为host_name-relay-bin。也可以使用绝对路径，以指定非数据目录来存储中继日志。作用范围为全局级别，可用于选项文件，属非动态变量。

        relay_log_index=file_name
        设定中继日志的索引文件名，默认为为数据目录中的host_name-relay-bin.index。作用范围为全局级别，可用于选项文件，属非动态变量。

        relay-log-info-file=file_name
        设定中继服务用于记录中继信息的文件，默认为数据目录中的relay-log.info。作用范围为全局级别，可用于选项文件，属非动态变量。


        relay_log_purge={ON|OFF}
        设定对不再需要的中继日志是否自动进行清理。默认值为ON。作用范围为全局级别，可用于选项文件，属动态变量。

        relay_log_space_limit=#
        设定用于存储所有中继日志文件的可用空间大小。默认为0，表示不限定。最大值取决于系统平台位数。作用范围为全局级别，可用于选项文件，属非动态变量。


        slow_query_log={ON|OFF}
        设定是否启用慢查询日志。0或OFF表示禁用，1或ON表示启用。日志信息的输出位置取决于log_output变量的定义，如果其值为NONE，则即便slow_query_log为ON，也不会记录任何慢查询信息。作用范围为全局级别，可用于选项文件，属动态变量。

        slow_query_log_file=/PATH/TO/SOMEFILE
        设定慢查询日志文件的名称。默认为hostname-slow.log，但可以通过--slow_query_log_file选项修改。作用范围为全局级别，可用于选项文件，属动态变量。


        sql_log_bin={ON|OFF}
        用于控制二进制日志信息是否记录进日志文件。默认为ON，表示启用记录功能。用户可以在会话级别修改此变量的值，但其必须具有SUPER权限。作用范围为全局和会话级别，属动态变量。

        sql_log_off={ON|OFF}
        用于控制是否禁止将一般查询日志类信息记录进查询日志文件。默认为OFF，表示不禁止记录功能。用户可以在会话级别修改此变量的值，但其必须具有SUPER权限。作用范围为全局和会话级别，属动态变量。

        sync_binlog=#
        设定多久同步一次二进制日志至磁盘文件中，0表示不同步，任何正数值都表示对二进制每多少次写操作之后同步一次。当autocommit的值为1时，每条语句的执行都会引起二进制日志同步，否则，每个事务的提交会引起二进制日志同步。

        max_allowed_packet
        限制server接受的数据包大小，默认为4M，如果导入数据比较大，会出现 MySQL server has gone away，可调整至10M~100M
